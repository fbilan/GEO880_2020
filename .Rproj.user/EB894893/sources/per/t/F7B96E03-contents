---
title: "Spatial and Temporal Patterns of “Metro Bike Share” Trips in Los Angeles"
subtitle: "Project for GEO880, Patterns and Trends in Environmental Data - Computational Movement Analysis"
author: "Fabian Biland & Laura Wysling"
output: 
  html_document:
    code_folding: hide
    fig_caption: yes
    highlight: tango
    number_sections: no
    theme: journal
    toc: yes
    toc_depth: 2
    toc_float: yes
---

```{r message=FALSE, warning=FALSE, eval = TRUE, echo = TRUE}
### Preliminaries ###
pkgTest <- function(x)
  {
    if (!require(x,character.only = TRUE))
    {
      install.packages(x,dep=TRUE)
        if(!require(x,character.only = TRUE)) stop("Package not found")
    }
}
pkgTest("dplyr")
pkgTest("lubridate")
pkgTest("ggplot2")
pkgTest("raster")
pkgTest("sf")
pkgTest("sp")
pkgTest("leaflet")
pkgTest("tidyverse")
pkgTest("geosphere")
pkgTest("rgeos")
pkgTest("spatstat")
pkgTest("maptools")

WGS84 <- "+init=epsg:4326"
NAD83 <- "+init=epsg:6423"

knitr::opts_chunk$set(echo = TRUE)
options(warning=FALSE)    # Don't show warnings
par(mfrow=c(1,1))         # Reset plot placement to normal 1 by 1
```

# Background and Research goals
___Insertfromdocs___

# Data and Methods
___Insertfromdocs___

## Dataset
___Insertfromdocs___

## Pre-Processing
___Insertfromdocs___

```{r message=FALSE, warning=FALSE, eval = TRUE, echo = TRUE}
### Load Data ###
all_stations <- st_read(file.path("Metro/All/Stations_all_0715.shp"), quiet = TRUE)
all_stations <- st_as_sf(all_stations, crs = NAD83)
all_stations <- st_transform(all_stations, crs = WGS84)
all_stations_sp <- as(all_stations, "Spatial")

biketrips <- read.csv("bike-trips-LA-q3.csv", sep = ",")
station_dic <- read.csv("station_table.csv", sep = ";")
station_dic <- station_dic[,1:2] %>% 
  mutate(Station_ID = as.character(Station_ID))


### Clear Data ###

# get rid of trips without coordinates and columns we don't need
biketrips <- biketrips[!is.na(biketrips$start_lat),]
biketrips <- biketrips[!is.na(biketrips$end_lat),]

# assign character for each cluster depending on coordinates
biketrips <- biketrips %>% mutate(cluster_start = ifelse(start_lat > 34.1364, "B", ifelse(start_lat < 33.8945, "C", ifelse(start_lon > -118.35, "A", "D"))))
biketrips <- biketrips %>% mutate(cluster_end = ifelse(end_lat > 34.1364, "B", ifelse(end_lat < 33.8945, "C", ifelse(end_lon > -118.35, "A", "D"))))

## are start and end region the same? yes, only for 3 trips they are different -> focus on cluster a
biketrips <- biketrips %>% mutate(within = ifelse(cluster_start == cluster_end, TRUE, FALSE))

# add hour, day, month and time to dataset and adjust data types
biketrips <- biketrips %>% 
  mutate(start_time=as.POSIXct(start_time, format="%m/%d/%Y %H:%M")) %>%
  mutate(start_hour = as.POSIXlt(start_time)$hour) %>%
  mutate(start_day=floor_date(start_time, unit="day")) %>% 
  mutate(start_month=floor_date(start_time, unit="month")) %>% 
  mutate(end_time=as.POSIXct(end_time, format="%m/%d/%Y %H:%M")) %>%
  mutate(end_hour = as.POSIXlt(end_time)$hour) %>%
  mutate(end_day=floor_date(end_time, unit="day")) %>% 
  mutate(end_month=floor_date(end_time, unit="month")) %>%
  mutate(start_station = as.character(start_station)) %>%
  mutate(end_station = as.character(end_station)) %>%
  mutate(start_lon = as.numeric(start_lon)) %>%
  mutate(start_lat = as.numeric(start_lat)) %>%
  mutate(end_lon = as.numeric(end_lon)) %>%
  mutate(end_lat = as.numeric(end_lat))

# calculate distance and velocity (convert to NAD83 and use pythagoras) and bind it to biketrips
biketrips_duration <- biketrips %>% group_by(duration) %>% summarize(count=n())
biketrips <- biketrips %>% filter(duration > 0, duration < 1430)
biketrips_start <- biketrips[c("start_lon", "start_lat")] %>% 
  st_as_sf(coords = c("start_lon", "start_lat"), crs = WGS84) %>% 
  st_transform(crs = NAD83)
biketrips_end <- biketrips[c("end_lon", "end_lat")] %>% 
  st_as_sf(coords = c("end_lon", "end_lat"), crs = WGS84) %>% 
  st_transform(crs = NAD83)
biketrips_dist <- st_coordinates(biketrips_start) %>% 
  cbind(st_coordinates(biketrips_end))
colnames(biketrips_dist) <- c("x1", "y1", "x2", "y2")
biketrips_dist <- as.data.frame(biketrips_dist) %>% mutate(distance = sqrt((x1-x2)**2 + (y1-y2)**2)/1000)
biketrips <- biketrips %>% cbind(distance = biketrips_dist$distance) %>% mutate(velocity = distance / duration*60)

# create sf object
bike_start_sf <- biketrips %>% st_as_sf(coords = c("start_lon", "start_lat"), crs = WGS84)

biketrips_a <- biketrips %>% filter(cluster_start == "A" & within == TRUE)
## Create overview map
pal <- colorFactor(c("navy", "red", "yellow", "orange"), domain = c("A", "B", "C", "D"))
content <- paste("Cluster: ", bike_start_sf$cluster_start)
overview_map <- leaflet(bike_start_sf) %>% 
  addProviderTiles(providers$CartoDB.Positron, options = providerTileOptions(opacity = 0.6)) %>%
  addRectangles(
      lng1=min(biketrips_a$start_lon)-0.02, lat1=min(biketrips_a$start_lat)-0.02,
      lng2=max(biketrips_a$start_lon)+0.02, lat2=max(biketrips_a$start_lat)+0.02,
      fillColor = "transparent", popup = "Research Area: Cluster A") %>%
  addCircleMarkers(color = ~pal(cluster_start), radius = 1, popup = content)


# Figure 1
overview_map


# number of trips in each cluster
ntrips_cluster <- biketrips %>% group_by(cluster_start) %>% summarize(count=n())

# get number of stations in cluster A
get_no_of_stations <- function(df){
  station1 <- df$start_station
  station2 <- df$end_station
  station1 <- as.vector(station1)
  station2 <- as.vector(station2)
  stations <- c(station1, station2)
  station <- unique(stations) # remove duplicates
  return(length(station))
}
station_dataset <- get_no_of_stations(biketrips)
station_a <- get_no_of_stations(biketrips_a)

overview_df <- data.frame("Level" = c("Overall", "Cluster A", "Rounded Proportion [%]"), 
              "Number_of_trips" = c(sum(ntrips_cluster$count), nrow(biketrips_a), round(nrow(biketrips_a)/sum(ntrips_cluster$count)*100)),
              "Number_of_stations" = c(station_dataset, station_a, round(station_a/station_dataset*100)))

# Table 1
overview_df
```

## Methods
___Insertfromdocs___

### Spatial Patterns
#### Most Popular Stations
___Insertfromdocs___
#### Metro Station Analysis
___Insertfromdocs___
#### Trip Pattern Analysis
___Insertfromdocs___

### Temporal Patterns
#### Time of the day
#### Weekday vs. Weekend
___Insertfromdocs___

# Results

```{r message=FALSE, warning=FALSE, eval = TRUE, echo = TRUE}
# some simple data exploration to get an idea what we're working with
biketrips_a_meanduration <- mean(biketrips_a$duration)
biketrips_a_meandistance <- mean(biketrips_a$distance)
cat(biketrips_a_meandistance,"is the mean duration")
biketrips_a_oneway <- biketrips_a %>% filter(trip_route_category != "Round Trip")
biketrips_a_meandistance <- mean(biketrips_a_oneway$distance)
cat(biketrips_a_meandistance,"is the mean distance")
biketrips_a_passholderdist <- biketrips_a %>% group_by(passholder_type) %>% summarize(count=n())
print(biketrips_a_passholderdist)


hourly_start <- biketrips_a %>% group_by(start_station, start_hour) %>% summarize(count=n())
colnames(hourly_start) <- c("Station_ID", "Hour", "Count_Start")
hourly_end <- biketrips_a %>% group_by(end_station, end_hour) %>% summarize(count=n())
colnames(hourly_end) <- c("Station_ID", "Hour", "Count_End")
hourly <- hourly_start %>% full_join(hourly_end, copy = FALSE, by= c("Station_ID", "Hour"))
hourly[is.na(hourly)] <- 0
hourly$diff <- hourly$Count_Start-hourly$Count_End
hourly <- hourly %>% inner_join(station_dic, copy = FALSE, by = "Station_ID")

## a lot of trips between Union station and Main/1st St (location of Los Angeles Department of Transportation)
ggplot(data = hourly, mapping = aes(x = Hour,
                                       y = Station_Name,
                                       fill = diff)) +
                                       geom_tile() +
                                       xlab(label = "Hour") +
                                       ylab(label = "Start Station") +
                                       ggtitle("Balance of trips starting (positive) and trips ending (negative)") +
                                       scale_fill_gradient2("Difference")

## extract the two most "popular" stations
twostations <- hourly %>% filter(Station_ID %in% c(3030, 3014))
total_trips_2stations <- biketrips_a %>% 
  filter(start_station %in% c(3030, 3014) | end_station %in% c(3030, 3014)) %>% 
  nrow()
total_between_2stations <- biketrips_a %>% 
  filter(start_station == 3030 & end_station == 3014 | start_station == 3014 & end_station == 3030) %>% 
  nrow()
# Only 27% of all trips starting or ending at either 3014 or 3030 are used for trips between the two stations
ratio_2stations <- total_between_2stations / total_trips_2stations

ggplot(data = twostations, mapping = aes(x = Hour,
                                          y = Station_Name,
                                        fill = diff)) +
                                       geom_tile() +
                                       xlab(label = "Hour") +
                                       ylab(label = "Start Station") +
                                       ggtitle("Balance of trips starting (positive) and trips ending (negative)") +
                                       scale_fill_gradient2("Difference")
```

#### Metro Station Analysis
```{r message=FALSE, warning=FALSE, eval = TRUE, echo = TRUE}
### Metro Station Analysis ###

a_sf <- st_as_sf(biketrips_a, coords = c("start_lon", "start_lat"), crs = WGS84)
a_sp <- as(a_sf, "Spatial")
a_sp <- spTransform(a_sp, CRS(WGS84))
a_sf_nad <- st_transform(a_sf, crs = NAD83)
a_sp_nad <- as(a_sf_nad, "Spatial")
a_coords <- st_coordinates(a_sf)

# Convex Hull to clip to relevant stations
a_hull <- gConvexHull(a_sp_nad) # use NAD object for buffer because it is a metric system and buffer
a_hull <- gBuffer(a_hull, width =300) # buffer of 300m
a_hull <- st_as_sf(a_hull)
a_hull <- st_transform(a_hull, crs = WGS84)

all_stations_within_a_hull <- st_intersection(a_hull, all_stations)

leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron, options = providerTileOptions(opacity = 0.6)) %>% 
  setView(lat=34.06699, lng=-118.2909,zoom=11)%>%
  addPolygons(data = a_hull, color = "darkred") %>%
  addCircleMarkers(data = a_sf, col = "darkblue4", radius = 1) %>%
  addCircleMarkers(data = all_stations, col = "black", radius = 2, popup=all_stations$STATION)

# create buffer around metro stations. First transform to sp to use buffer function
all_stations_nad <- st_transform(all_stations, crs = NAD83)
all_stations_sp <- as(all_stations_nad, "Spatial")
all_stations_coords <- st_coordinates(all_stations)
all_stations_buffer <- buffer(all_stations_sp, width=300)
all_stations_buffer <- st_as_sf(all_stations_buffer)
all_stations_buffer <- st_transform(all_stations_buffer, crs = WGS84)

all_bike_trips_within_metro_buffer <- st_intersection(all_stations_buffer, a_sf)
trips_in_buffer_count_start <- all_bike_trips_within_metro_buffer %>% group_by(start_station) %>% summarize(count=n())
popup_start <- paste("Station Name: ", trips_in_buffer_count_start$start_station, "count: ", trips_in_buffer_count_start$count)
all_bike_stations_within_metro_buffer <- st_intersection(all_stations_buffer, trips_in_buffer_count_start)
cat(nrow(all_bike_stations_within_metro_buffer), "bike stations lie within the metro buffers")

leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron, options = providerTileOptions(opacity = 0.6)) %>% 
  setView(lat=34.06699, lng=-118.2909,zoom=12)%>%
  addPolygons(data = all_stations_buffer, color = "darkred") %>%
  addPolygons(data = a_hull, color = "darkred") %>%
  addCircleMarkers(data = a_sf, col = "darkblue4", radius = 0.7, fillOpacity=0.6, group="Bike Stations in Convex Hull")%>%
  addCircleMarkers(data = all_bike_stations_within_metro_buffer, col = "black", radius = 1, popup = all_bike_stations_within_metro_buffer$STATION, group = "Bike Stations in Metro buffer") %>%
  addCircleMarkers(data = trips_in_buffer_count_start, col = "black", popup = popup_start, radius=sqrt(trips_in_buffer_count_start$count), opacity=0.4, group = "Number of Trips from Stations in Metro buffers")%>%
  addLayersControl(overlayGroups=c("Bike Stations in Convex Hull", "Bike Stations in Metro buffer", "Number of Trips from Stations in Metro buffers"), options=layersControlOptions(collapsed=FALSE))%>%
  hideGroup("Number of Trips from Stations in Metro buffers")

# ratio of trips that start within metro buffer and trips in cluster A
ratio_metrocluster <- nrow(all_bike_trips_within_metro_buffer) / nrow(a_sf)
cat(ratio_metrocluster, "is the ratio of trips that start within metro buffer and trips in cluster A")

# calculate shortest distance from stations to metro stations
a_stations <- biketrips_a[6:7] %>% unique()
a_stations <- a_stations %>% 
  st_as_sf(coords = c("start_lon", "start_lat"), crs = WGS84) %>% 
  st_transform(crs = NAD83) %>% 
  as("Spatial")
dist_stations_bikemetro<- nncross(X=as.ppp.SpatialPointsDataFrame(a_stations), Y=as.ppp.SpatialPointsDataFrame(all_stations_sp), k=1) 

hist(dist_stations_bikemetro$dist, col = "grey", breaks = 20, prob = TRUE, main="Density of shortest distance from bike to Metro station", xlab="Distance [m]")
lines(density(dist_stations_bikemetro$dist), lwd = 2, add = T)
```

```{r message=FALSE, warning=FALSE, eval = TRUE, echo = TRUE}


```


#### Trip Pattern Analysis
```{r message=FALSE, warning=FALSE, eval = TRUE, echo = TRUE}
### Trip Pattern Analysis ###

# extract whether multiple people are moving together (start and end at the same time at the same station)
biketrips_a$together <- FALSE

time_diff_ok <- function(trip_a, trip_b){
  diff_starttime <- biketrips_a$start_time[trip_a]-biketrips_a$start_time[trip_b]
  diff_endtime <- abs(biketrips_a$end_time[trip_a]-biketrips_a$end_time[trip_b]) # absolute value because end_time is not sorted
  if (diff_starttime < 3 & diff_endtime < 3){
    return("TRUE")
  }
  else {
    return("FALSE")
  }
}

for (trip in 1:nrow(biketrips_a)){
  for (minus in 1:100){
    if (trip-minus > 0){
      if (biketrips_a$start_station[trip] == biketrips_a$start_station[trip-minus] & biketrips_a$end_station[trip] == biketrips_a$end_station[trip-minus]){
      if (time_diff_ok(trip, trip-minus) == "TRUE"){
        biketrips_a$together[trip] <- TRUE
        biketrips_a$together[trip-minus] <- TRUE
      }
    }
  }
  } 
}
tog <- biketrips_a %>% filter(together == TRUE) %>% nrow()
ratio <- tog / nrow(biketrips_a)
ratio # ratio of people cycling together
commuter <- biketrips_a %>% filter(trip_route_category != "Round Trip" & velocity > 12 & passholder_type %in% c("Monthly Pass", "Annual Pass", "Flex Pass") & duration < 30 & together == FALSE) %>% filter(between(start_hour, 5, 9) | between(start_hour, 16, 20)) %>% mutate(purpose = "commuter")
tourist <- biketrips_a %>% filter(velocity < 12 & passholder_type %in% c("One Day Pass", "Walk-up") | together == TRUE) %>% mutate(purpose = "tourist")
electric <- biketrips_a %>% filter(bike_type == "electric")
standard <- biketrips_a %>% filter(bike_type == "standard")


par(mfrow=c(1,3))
biketrips_a$bike_type <- factor(biketrips_a$bike_type)
boxplot(biketrips_a$duration ~ biketrips_a$bike_type, col="grey", main = "Duration", xlab = "Bike Type", ylab = "Duration [min]", outline = FALSE)
boxplot(biketrips_a$velocity ~ biketrips_a$bike_type, col="grey", main = "Velocity", xlab = "Bike Type", ylab = "Velocity [km/h]")
boxplot(biketrips_a$distance ~ biketrips_a$bike_type, col="grey", main = "Distance", xlab = "Bike Type", ylab = "Distance [km]")
par(mfrow=c(1,1))


# attempt to predict distance out of duration for round trips (because they have no distance) -> failed
bike_plot <- biketrips_a %>% filter(distance > 0.001)
linearMod <- lm(distance ~ duration, data=bike_plot)
summary(linearMod) # adj. rsquared 1.73% -> very low

scatter.smooth(x=bike_plot$distance, xlab="Trip Distance", y=bike_plot$duration, ylab="Trip Duration", main="Dist ~ Speed: All bike trips in cluster A")
scatter.smooth(x=tourist$distance, xlab="Trip Distance", y=tourist$duration, ylab="Trip Duration", main="Dist ~ Speed: Bike trips with purpose tourism")
```
#### Weekday vs. Weekend

```{r message=FALSE, warning=FALSE, eval = TRUE, echo = TRUE}
biketrips_a$weekday <- weekdays(as.Date(biketrips_a$start_day)+1) # the weekday is only correct with +1
weekday_count <- biketrips_a %>% group_by(start_hour, weekday) %>% summarize(count=n())
dayLabs<-c("Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag","Sonntag") 
weekday_count$weekday <- factor(weekday_count$weekday, levels = rev(dayLabs))
weekday_count <-weekday_count[order(weekday_count$weekday), ]

# de plot isch überflüssig (und mir hend so eine obe scho)
# ggplot(data = weekday_count, mapping = aes(x = start_hour,
#                                           y = weekday,
#                                         fill = count)) +
#                                        geom_tile() +
#                                        xlab(label = "Hour") +
#                                        ylab(label = "Weekday") +
#                                        ggtitle("Absolute number of trips for each day") +
#                                        scale_fill_gradient("Count")

# function to retrieve the statistics for a specific day
# number is the number of mondays (e.g.) in the dataset. Monday appears 14 times, the rest 13 times
weekday_count <- biketrips_a %>% group_by(weekday) %>% summarize(count=n())
weekday_count$weekday <- factor(weekday_count$weekday, levels = dayLabs)
weekday_count <-weekday_count[order(weekday_count$weekday), ]
weekday_count$mean_trips <- round(weekday_count$count/14,2) # 14 weeks are included in dataset
weekday_count$mean_trips[1] <- round(weekday_count$count[1]/15,2) # monday is included 15 times (14 weeks + 1 day)
weekday_count$percentage <- round(weekday_count$count/sum(weekday_count$count),3)*100
weekday_count
weekday_count_new <- biketrips_a %>% 
  group_by(start_hour, weekday %in% dayLabs[1:5]) %>% 
  summarize(count=n())
names(weekday_count_new)[2] <- "type"
weekday_count_new <- weekday_count_new %>% mutate(type = ifelse(type == TRUE, "WeekDAY", "WeekEND"))
weekend <- weekday_count_new %>% filter(type == "WeekEND") %>% mutate(count = count/2) #normalize per day
weekday <- weekday_count_new %>% filter(type == "WeekDAY") %>% mutate(count = count/5) #normalize per day

plot(x=weekday$start_hour, y=weekday$count, type = "b", pch = 19, col = "blue", xlab = "Start Hour", ylab = "Number of trips", main ="Average number of trips per Day-Type")
lines(weekend$start_hour, y=weekend$count, type = "b", pch = 19, col = "green", add = T)
legend("topleft", legend=c("Weekday-Day", "Weekend-Day"),col=c("blue", "green"), lty = 1, cex=0.8)
```

#### Weekday vs. Weekend
```{r message=FALSE, warning=FALSE, eval = TRUE, echo = TRUE}
### Temporal Analysis ###


day_hour <- function(day, number){ 
  day_stat <- biketrips_a %>% filter(weekday == day) %>% group_by(start_hour) %>% summarize(count = n()) %>% mutate(count = count/number)
  return (day_stat) 
}
monday <-day_hour("Montag", 14)
tuesday <- day_hour("Dienstag", 13)
wednesday <- day_hour("Mittwoch", 13)
thursday <- day_hour("Donnerstag", 13)
friday <- day_hour("Freitag", 13)
saturday <- day_hour("Samstag", 13)
sunday <- day_hour("Sonntag", 13)

# plot(day)
plot(monday$start_hour, monday$count, type = "o", col = "blue", ylim = c(0,90), main = "Average number of trips on each day of the week", xlab = "Hour", ylab = "Count")
lines(tuesday$start_hour, tuesday$count, type = "o", col = "red")
lines(wednesday$start_hour, wednesday$count, type = "o", col = "chartreuse4")
lines(thursday$start_hour, thursday$count, type = "o", col = "blueviolet")
lines(friday$start_hour, friday$count, type = "o", col = "darkorange")
lines(saturday$start_hour, saturday$count, type = "o", col = "gray")
lines(sunday$start_hour, sunday$count, type = "o", col = "black")
legend("topleft", legend=c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"),col=c("blue", "red", "chartreuse4", "blueviolet", "darkorange", "gray", "black"), lty = 1, cex= 0.8)
```

# Discussion
___Insertfromdocs___

# Sources
___Insertfromdocs___

